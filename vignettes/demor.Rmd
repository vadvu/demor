---
title: "Get started with `demor`"
output: rmarkdown::html_vignette
bibliography: ref.bib
link-citations: TRUE
toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Get started with `demor`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE, 
  message = FALSE,
  comment = "#>"
)
```

# Installation

You can install the development version of `demor` from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("vadvu/demor")
```

```{r setup, echo=FALSE}
library(demor)
library(ggplot2)
library(dplyr)
library(tidyr)
```

# Get Rosbris data

The data from @rosbris is presented in the `demor` as datasets in the long-format (mortality/fertility by 1/5-year age groups from 1989 to 2022).\

The example of usage is placed below, where data on mortality by 5-year age groups is presented:

```{r}
dbm <- demor::rosbris_mortality_pop_5

# for 1-year age interval
# dbm <- demor::rosbris_mortality_pop_1
```


Lets see the data for Russia in 2010 for males and for total population (both urban and rural)

```{r}
dbm[dbm$year==2010 & dbm$code==1100 & dbm$sex=="m" & dbm$territory=="t",]
```

# Mortality

## Life table

Now one can create *life table* based on gotten data for 2010-Russia using `LT()`.\
Note, $a_x$ for age 0 is modeled as in @Andreev_ax, while the function can use user-specific $a_x$ from the argument `ax`. However, despite there is a plethora of methods to construct life table that “are based upon very different assumptions, when applied to actual mortality rates they do not result in significant differences of importance to mortality analysis.” [WHO, 1977, p. 70, cite from @preston, p. 47]. For example, changing $a_0$ to 0.5 only increases the life expectancy $e_0$ by $\approx +0.01$ for the 2010 Russian male population, which is about 4 days when applied to human life span. 

```{r}
rus2010 <- dbm[dbm$year==2010 & dbm$code==1100 & dbm$sex=="m" & dbm$territory=="t",]

LT(
  age = rus2010$age, 
  sex = "m", 
  mx = rus2010$mx #age specific mortality rates (mx)
  )

```

Note, from life table one can compute other *functions* (not just $e_x$) and quantities of interest:

1. Crude death rate $CDR = 1/e_0 = \sum_x D_x / \sum_x N_x$ or death rate above some age $x: 1/e_x$ 
2. Probability of surviving from age $x$ to age $y$: $p(x,y)=l_y/l_x \approx exp(-m_x \times n)$
3. Probability that a newborn will die between ages $x$ and $x+n$: $d_x^n/l_0$
4. Probability that a newborn will die between ages $x$ and $y$: $(l_x-l_y)/l_0$
5. Probability that a newborn will survive to age $x$: $p(x) = l_x/l_0$
6. Probability that a newborn will die in age $x$: $q(x) = 1-p_x$
6. Life course ratio from age $x$ to $y$ that is the fraction of person-years lived from age $x$ onward: $T_y/T_x$
7. Crude estimate of the number of births needed to “replace” expected deaths: $P/e_0$ where $P$ is total population


See also @preston.  

The life table is the one of the most important demographic tools that can be used not only for mortality, but for any other decrement processes (for ex., marital, occupation, migration status and etc). 

## Human Life Indicator (HLI)

A good alternative to the *human development indicator* (HDI) is the *human life indicator* (HLI) proposed by @hli. It requires just $m_x$ (and it is based on *life table*). 
It is calculated as geometric mean of lifespans: 
$$HLI = \prod_x^\omega{(x+a_x)^{d_x}}$$ 
where $x$ is age and $a_x$, $d_x$ are functions from *life table* that corresponds to age $x$.

Calculation in the `demor` is as follows (one need only $m_x$):

```{r}

hli(
  age = rus2010$age, 
  mx = rus2010$mx,
  sex = "m"
  )

```

## Gini coefficient

As @Shkolnikov_gini note, "at present, the average level of life expectancy is high in many countries and it is interesting to study to what extent this advantage is equally accessible to all people". (p. 306). One of the tools for analysing mortality inequality within the population (or, rather, the life table) is the Gini index, which is similar to the "usual" index widely used in economics. Life table Gini, $G_0$, shows a degree of inter-individual variability in age at death and can be interpreted as in other fields ($G_0 \in [0,1]$; higher $G_0$, higher inequality and vice versa). Also one can be interested in "absolute" Gini coefficient (aka AID - Absolute Inter-individual Difference) that is $G_0^{abs} = G_0 \times e_0$ which "is equal to the average inter-individual difference in length of life and is measured in years." [@Shkolnikov_gini, p. 312]

Below is the function `gini` that computes Gini index as well as produces data for Lorenz curve - the graphical representation of inequality. The formulas for the calculations are derived from @Shkolnikov_gini (that is based on the @hanada_gini formulation). 

```{r}
dbm.1 <- demor::rosbris_mortality_pop_1
mx <- dbm.1[dbm.1$code==1100 & dbm.1$territory=="t" & dbm.1$sex=="f" & dbm.1$year == 1995,]$mx
res = gini(age = 0:100, mx = mx, sex = "f")
res$Gini

```

Note, in @Shkolnikov_gini the $G_0 = 0.13$ (see p. 310, figure 1), while using `gini` one obtains 0.1295. Also note that the larger the age interval, the less accurate the estimate will be, since it is based on a discrete approximation of a continuous function. 

Below is an example of Lorenz curve that can be created using ggplot2 and `gini` output. 

```{r}

res$plot %>% 
  ggplot(aes(Fx, Phix))+
  geom_line(color = "red")+
  geom_abline(intercept = 0, slope = 1)+
  scale_x_continuous(limits=c(0,1), expand = c(0, 0)) +
  scale_y_continuous(limits=c(0,1),expand = c(0, 0)) +
  theme_classic()+
  labs(x = "Proportion in population", y = "Proportion in person-years of life")+
  ggtitle("Lorenz curve: Russia, 1995, females", 
          subtitle = paste0("G0 = ", round(res$Gini$G0, 2), ", ", 
                            "G0 abs = ", round(res$Gini$G0_abs, 2), ", ",
                            "e0 = ", round(res$Gini$G0_abs/res$Gini$G0, 2))
          )

```

Note, one can calculate not only Gini *inequality* index, but also Drewnowski’s index of *equality* that is $D_0 = 1 - G_0$ proposed by @Drewnowski (so, for Russian 1995 females it is $1-0.13=0.87$) that also can serve as an indicator of the shape of mortality patterns.

## e-dagger

Another measure of mortality inequality is "e-dagger", $e^{\dagger}_x$, proposed by @edagger, that is approximation of "the average life expectancy lost because of death" [@edagger, p. 206]. 

In `demor` there is a function `edagger` for calculation "e-dagger" for age $x$, $e^{\dagger}_x$:

```{r}

mx <- dbm.1[dbm.1$code==1100 & dbm.1$territory=="t" & dbm.1$sex=="f" & dbm.1$year == 1995,]$mx
res = edagger(age = 0:100, mx = mx, sex = "f")
res[c(1, 26, 51, 76)]

```

Hence, $e_0^{\dagger}$ for Russian female population in 1995 is 12.72. From $e^{\dagger}_x$ one can also calculate life table entropy $H_x$ [see, for ex., @comp_ineq2] that is simply $H_x = e^{\dagger}_x/e_x$. Usually only one quantity as entropy is presented that is $H_0$, which sometimes is denoted as $\bar H$, and it is $e^{\dagger}_0/e_0$. 

Note that the larger the age interval, the less accurate the estimate will be, since it is based on a discrete approximation of a continuous function. 

For more inequality indicators and their comparisons, see @Shkolnikov_gini, @comp_ineq2 and @comp_ineq1 as well as [`LifeIneq`](https://github.com/alysonvanraalte/LifeIneq) package. 


## Years of Life Lost (YLL)

One of the most popular (and relatively young) measure of *lifespan inequality* is "*years of life lost*" (YLL) proposed in @yll. As authors claim, "YLL is a valuable measure for public health surveillance, particularly for quantifying the level and trends of premature mortality, identification of leading causes of premature deaths and monitoring the progress of YLL as a key indicator of population health" [@yll, p. 1368].

Authors proposed different metrics of *YLL*:

1. Absolute number of *YLL*: $$YLL_{x,t,c}=D_{x,t,c}*SLE_x$$ that is calculated for age *x*, time *t* and cause of death *c*. *YLL* for the whole population is just sum of $YLL_x$. *SLE* is the *standard life expectancy* that is invariant over time, sex and population (it's meaning is straightforward: it is the potential maximum life span of an individual, who is not exposed to avoidable health risks or severe injuries and receives appropriate health services), and $D_x$ is a number of deaths at age *x*. Of course, one can calculate *YLL* not for specific cause *c*, but for overall mortality that is called *all-causes YLL*.
2. *YLL* as proportion: $$YLL^p_{x,t,c}=YLL_{x,t,c}/YLL_{x,t}$$ that is just *cause specific YLL* divided by *all-causes YLL*.
3. *YLL* rate: $$YLL^r_{x,t,c}=[YLL_{x,t,c}/P_{x,t}] * 100'000$$ where $P_{x,t}$ is population.
4. Age-standardized *YLL* rate: $$ASYR_{x,t,c} = \sum_x^\omega{[YLL^r_{x,t,c}*W_x]}$$ where $W_x$ is the standard population weight at age *x*, where $\omega$ is the oldest, closing age (for ex., 85+ or 100+). In other words, it's just direct standardization of $YLL^r_{x,t,c}$.

Let's calculate all-cause *YLL*, *Yll rate* and *ASYR* using Rosbris data that we have downloaded.

```{r}
#YLL
yll(rus2010$Dx, type = "yll")

```

```{r}
#YLL rate
yll(rus2010$Dx, type = "yll.r", pop = rus2010$N)

```

For *ASYR* one needs standard population. Let's use 2010 population as standard (note, in this case *ASYR* equals *YLL rate* because we use 2010 mortality).

```{r}
#ASYR
yll(rus2010$Dx, type = "asyr", pop = rus2010$N, w = rus2010$N/sum(rus2010$N))

```

Also one can calculate different *YLL* measures using standards that are provided by `demor` as dataframe.

``` r
demor::sle_stand
```

## Age decomposition of differences in life expectancies

Also one can do simple *decomposition* between 2 populations. Lets use Russia-2000 as *base population* and Russia-2010 as *compared population*. This function implements three almost identical discrete methods that were proposed almost simultaneously: in @andreev_dec, in @arriaga_dec and in @pollard_dec.  

```{r}
rus2010 <- dbm[dbm$year==2010 & dbm$code==1100 & dbm$sex=="m" & dbm$territory=="t",]
rus2000 <- dbm[dbm$year==2000 & dbm$code==1100 & dbm$sex=="m" & dbm$territory=="t",]

dec <- decomp(mx1 = rus2000$mx, 
              mx2 = rus2010$mx, 
              age = rus2000$age, 
              method = "andreev")
head(dec)

```

Than let us plot the result of `decomp` using `ggplot2`: 

```{r}
ggplot(dec, aes( as.factor(age), ex12))+
  geom_bar(stat = "identity", color = "black", fill = "orange3")+
  theme_minimal()+
  labs(x = "Age-groups", 
       y = "Сontribution to the e0 difference")+
  annotate("text", x = "70", y = 0.5, label = paste0("Total difference in e0: ", sum(dec$ex12)))+
  geom_text(aes(label = ex12), vjust = 1.5, color = "white", size = 3.5)
```

## Age and cause decomposition of differences in life expectancies

Also one can do *decomposition* between 2 populations by *age* and *causes*. Lets use example from @and_sch_mdecomp where data for US and England and Wales men mortality by some causes are presented.

Lets see the data

```{r}
data("mdecompex")
head(mdecompex)
```

For `mdecomp` 2 lists with arrays for 2 population are required.

```{r}
#US men
mx1 <- mdecompex %>% 
  filter(cnt == "usa") %>% 
  select(-cnt, -age) %>% select(all, everything()) %>% 
  as.list()

#England and Wales men
mx2 <- mdecompex %>% 
  filter(cnt == "eng") %>% 
  select(-cnt, -age) %>% select(all, everything()) %>% 
  as.list()

decm <- mdecomp(mx1 = mx1, 
              mx2 = mx2, 
              sex = "m", 
              age = unique(mdecompex$age), 
              method = "andreev"
              )
head(decm)
```

Than let us plot the result of `mdecomp` using [ggplot2](https://github.com/tidyverse/ggplot2). This requires some data transformations

```{r}
decm_plot <- decm[,c(1,3)]
decm_plot$group = colnames(decm)[3]
colnames(decm_plot)[2]<-"ex12"
for(i in 4:ncol(decm)){
  decm_plot_i <- decm[,c(1,i)]
  decm_plot_i$group = colnames(decm)[i]
  colnames(decm_plot_i)[2]<-"ex12"
  decm_plot <- rbind(decm_plot,decm_plot_i)
  rm(decm_plot_i)
}

for (i in unique(decm_plot$group)){
  decm_plot[decm_plot$group==i,]$group <- paste0(i, " (", round(sum(decm_plot[decm_plot$group==i,]$ex12),2), ")")
}

ggplot(data = decm_plot, aes(x = as.factor(age), y = ex12, fill = group))+
  geom_bar(stat="identity", colour = "black")+
  theme_minimal()+
  scale_fill_brewer(palette="Set1")+
  labs(x = "Age", y = "Contribution to difference in ex", fill = "Cause (contribution):", 
       caption  = paste0("Total difference in ex = ", sum(decm[,2]))
       )
```

## Multiple Decrement Life Table

Also one can construct the Multiple Decrement Life Table that expands the usual life table adding additional columns ($q_x^i, d_x^i, l_x^i \ \forall \ \text{causes} \ i$) for specific decrement causes. Note, $m_x = \sum_i m_x^i$ and user should specify $m_x$ (the first array in the list). Let us use the shorten vesrion of data from the previous example, using only overall $m_x$ and $m_x^i$ from neoplasm. 

```{r}
mx <- mx1[c("all", "neoplasms")]
age = unique(mdecompex$age)
mlt.res = MLT(age, mx)
head(mlt.res)
```

From this table one can calculate, for ex.,

- Proportion of newborn that will eventually die from cause i: $l_0^i/l_0$
- Proportion of people who survive to age $x$ that will die from cause i: $l_x^i/l_x$ 

## Associated single decrement life table

There is `asdt()` function that calculates *associated single decrement life table* (ASDT) for causes of death (*cause-deleted life table*). In other words, by this function one can answer the question "what will be the life expectancy if there is no mortality from cause i?" It is a natural expansion of Multiple Decrement Life Table (`MLT` function, see above)

For example in the `demor` data (as it is easy to guess, taken from @and_sch_mdecomp) on mortality of US men in 2002 by some causes is added. Let me show what would be $e_x$ if there is no deaths from neoplasm (i).

```{r}
data("asdtex")

asdt_neoplasm <- asdt(age = asdtex$age, 
                      sex = "m",
                      m_all = asdtex$all, 
                      m_i = asdtex$neoplasms, 
                      full = F, 
                      method = "chiang1968")

head(asdt_neoplasm[,c("age", "ex", "ex_without_i")])

```

One can plot the results using [ggplot2](https://github.com/tidyverse/ggplot2):

```{r}

ggplot(data = asdt_neoplasm, aes(x = age))+
  geom_line(aes(y = ex, color = "ex all"), size = 1)+
  geom_line(aes(y = ex_without_i, color = "ex without neoplasms"), size = 1)+
  theme_linedraw()

ggplot(data = asdt_neoplasm, aes(x = age))+
  geom_line(aes(y = lx, color = "lx all"), size = 1)+
  geom_line(aes(y = l_not_i, color = "lx without neoplasms"), size = 1)+
  geom_hline(yintercept = 0.5, linetype = "dashed")+
  theme_linedraw()

```

## Mortality models for mx approximation

In `demor` there is a function `mort.approx` for modeling mx. Now "Gompertz" and "Brass" are supported (see Preston, Heuveline & Guillot, 2001 for more details on the functions). 

Function returns list with estimated model and dataframe with predicted mx.

The example below shows the model that try to approximate mx of russian men in 2010 using Brass function and russian mortality of 2000 as standard mortality. 

```{r}
rus2010 <- dbm[dbm$year==2010 & dbm$code==1100 & dbm$sex=="m" & dbm$territory=="t",]
rus2000 <- dbm[dbm$year==2000 & dbm$code==1100 & dbm$sex=="m" & dbm$territory=="t",]


brass_2010 <- mort.approx(mx = rus2010$mx,
                          age = rus2010$age,
                          model = "Brass",
                          standard.mx = rus2000$mx,
                          sex = "m")
brass_2010[[1]]
```


Lets plot the modeled and observed mx.

```{r}
brass_2010[[2]] %>% 
  mutate(mx = rus2010$mx) %>% 
  ggplot(aes(x = age))+
  geom_line(aes(y = log(mx), color = "Observed"), linewidth = 1)+
  geom_line(aes(y = log(mx.pred), color = "Predicted"), linewidth = 1)+
  theme_linedraw()+
  scale_color_manual(values = c("blue", "red"))+
  labs(x = "Age", y = "ln mx")
```


```{r}
model1 <- mort.approx(mx = rus2010$mx[-c(1:6)], age = rus2010$age[-c(1:6)], model = "Gompertz")
```


```{r, echo=FALSE}
model1.comp <- model1$predicted %>% 
  as.data.frame() %>% 
  mutate(type = "pred") %>% 
  rbind(data.frame(age = seq(90, 100, 5)) %>% 
          mutate(mx.pred = exp(predict(model1$model, data.frame(age = seq(90, 100, 5)))),
                 type = "pred"
                 )
        ) %>% 
  filter(age > 85) %>% 
  rbind(data.frame(age = rus2010$age, mx.pred = rus2010$mx, type = "obs5")) %>% 
  arrange(age)


model1.comp$lx <- NA
model1.comp[model1.comp$type == "obs5",]$lx <- 
  LT(age = rus2010$age, mx = rus2010$mx)[,"lx"]
model1.comp[model1.comp$type == "pred",]$lx <- 
  LT(age = model1.comp$age, mx = model1.comp$mx)[model1.comp$age > 85,"lx"]


model1.comp %>% 
  rbind(x = ., y = model1.comp[model1.comp$age == 85,] %>% mutate(type = "pred")) %>% 
  mutate(mx.pred = log(mx.pred)) %>% 
  pivot_longer(cols = c("mx.pred", "lx"), names_to = "indic", values_to = "count") %>% 
  mutate(indic = ifelse(indic == "lx", "lx", "mx (ln)"),
         type = ifelse(type == "obs5", "Observed", "Model")
         ) %>% 
  ggplot(aes(age, count, color = type))+
  geom_line()+
  geom_point()+
  facet_wrap(~indic, scales = "free")+
  theme_linedraw()+
  scale_color_manual(values = c("red", "black"))+
  labs(x = "", y = "", color = "")
```



# Fertility

## Get fertility data

The data from @rosbris is presented in the `demor` as datasets in the long-format (mortality/fertility by 1/5-year age groups from 1989 to 2022). Lets get basic *fertility data* (asFR or $f_x$) from `demor`:

```{r}
dbf <- demor::rosbris_fertility_pop_1
```

For the example Russia-2010 is as follows

```{r}
rus2010f <- dbf[dbf$year==2010 & dbf$code==1100 & dbf$territory=="t",]
head(rus2010f)
```

## TFR

Now one can compute total fertility age (*TFR*) - the most popular measure of fertility - that is standardized measure of "the average number of children a woman would bear if she survived through the end of the reproductive age span and experienced at each age a particular set of age-specific fertility ages" [@preston, p. 95]. 

Surely, using `tfr` function one can compute TFR by parity whereby using $f_x^p$ instead of overall $f_x$. 

```{r}
tfr(
  #asFR
  rus2010f$fx,
  #age interval
  age.int = 1
    )
```

## Tempo-adjusted TFR

However, period "TFR is a very problematic measure for assessing both the need for and the impact of policy changes and, more generally, for studying fertility trends in conjunction with selected social and economic trends" [@sobotka2010misleading, p. 639]. One correction to usual TFR is a tempo (meaning fertility schedule) adjusted TFR, TFR', proposed by @bongaarts_tfr1 (see also @bongaarts_tfr2). To calculate it, one can use `tatfr` function: 

```{r}

dbf5 <- demor::rosbris_fertility_pop_5 %>% dplyr::filter(code == 1100 & year %in% 2009:2011 & territory == "t")

past_fx = dbf5[dbf5$year == 2009,] %>% select(6:10) %>% as.list()
present_fx = dbf5[dbf5$year == 2010,] %>% select(6:10) %>% as.list()
post_fx = dbf5[dbf5$year == 2011,] %>% select(6:10) %>% as.list()

tatfr(past_fx = past_fx, present_fx = present_fx, post_fx = post_fx, age = seq(15, 50, 5))
```


```{r, echo=FALSE}
fpall <- demor::rosbris_fertility_pop_5 %>% filter(code == 1100 & territory == "t")
da <- data.frame(year = 1990:2022, tfrA = NA, tatfrA = NA)
for(i in 1:5){
  da[paste0("tfr", i)] <- da[paste0("tatfr", i)] <- NA
}
for(y in 1991:2021){
  past_fx = fpall[fpall$year == y-1,] %>% select(6:10) %>% as.list()
  present_fx = fpall[fpall$year == y,] %>% select(6:10) %>% as.list()
  post_fx = fpall[fpall$year == y+1,] %>% select(6:10) %>% as.list()
  resik <- tatfr(past_fx = past_fx, present_fx = present_fx, post_fx = post_fx, age = seq(15, 50, 5))
  da[da$year == y,"tfrA"] <- resik$tfr
  da[da$year == y,"tatfrA"] <- resik$tatfr
  for(i in 1:5){
    da[da$year == y, paste0("tfr", i)] <- resik$tfr_i[i]
    da[da$year == y, paste0("tatfr", i)] <- resik$tatfr_i[i]
  }
}

library(stringr)

da %>% 
  pivot_longer(cols = -year, names_to = "ind", values_to = "count") %>% 
  mutate(indic = str_sub(ind, end = -2),
         parity = str_sub(ind, start = -1)
         ) %>% 
  mutate(parity = ifelse(parity == "5", "5+", parity)) %>% 
  mutate(parity = ifelse(parity == "A", "Parity: All", paste("Parity: ", parity)),
         indic = ifelse(indic == "tfr", "TFR", "TFR*")
         ) %>% 
  ggplot(aes(x = year, y = count, color = indic, linetype = indic, shape = indic))+
  geom_line()+
  geom_point()+
  scale_color_manual(values = c("black", "red"))+
  scale_linetype_manual(values = c("solid", "longdash"))+
  labs(color = "Index:", linetype = "Index:", shape = "Index:", y = "Births per woman", x = "Year")+
  theme_linedraw()+
  facet_wrap(~parity, scales = "free")
```


## MAC

MAC is a mean age at childbearing. One can compute it using $f_x$. Surely, using `mac` function one can compute mean age at childbearing by parity whereby using $f_x^p$ instead of overall $f_x$. 

```{r}
mac(
  #asFR
  rus2010f$fx,
  #array with ages
  age = 15:55
    )
```

## Fertility models for ASFR approximation

In `demor` there is a function `fert.approx` for modeling ASFR. Now "Hadwiger", "Gamma", "Beta" and "Brass" are supported (see @peristera2007modeling for more details on the functions). 

Hadwiger model (optimal choice with balance of simplicity and accuracy) is as follows: 

$$f(age) = \frac{ab}{c} (\frac{c}{age})^{3/2} exp[-b^2(\frac{c}{age}+\frac{age}{c}-2)]$$
where $a,b,c$ - parameters. 

Gamma model (sophisticated and accurate, but not really sustainable due to convergence issues) is as follows: 
$$f(age) = \frac{R}{\Gamma(b)c^b}(age-d)^{b-1} exp[-(\frac{age-d}{c})]$$
where $R,b,c,d$ - parameters. 

Beta model (sophisticated and even more accurate than Gamma, but not really sustainable due to convergence issues) is as follows: 
$$f(age) = \frac{R}{B(A,C)}(\beta - \alpha)^{-(A+C-1)}(age - \alpha)^{(A-1)}(\beta - age)^{(B-1)}$$
where $B(.)$ is a beta function, $R, \beta, \alpha$ - parameters and
$$C = (\frac{(v-\alpha)(\beta-v)}{\tau^2} -1)\frac{\beta - v}{\beta -\alpha}, \ \ \ A = C\frac{v-\alpha}{\beta - v}$$
where $v, \tau^2$ - parameters.

Brass model (the simplest and the most inaccurate) is as follows: 

$$f(age) = c(age-d)(d+w-age)$$
where $c,d,w$ - parameters.

Function returns list with estimated model and dataframe with predicted ASFR.

The example below shows the model that try to approximate ASFR of russian women in 2010 using Gamma function. 

```{r}
approximation_2010 = fert.approx(fx = rus2010f$fx, age = 15:55, model = "Gamma", se = T)

approximation_2010[[1]]

```

Lets plot the modeled and observed ASFR with bootstrapped 95% CI. One can see that model perfectly approximates real ASFR from 15 to 40 ages, while after the fit is not really good. 

```{r}
data = approximation_2010[[2]]
ggplot(data = data, aes(x = age))+
  geom_point(aes(y = fx, color = "Observed fx"), linewidth = 1)+
  geom_line(aes(y = fx.model, color = "fx from Gamma model"), linewidth = 1)+
  geom_ribbon(aes(ymin = prc.low, ymax = prc.high, x = age, color = "95% CI"), 
              alpha = 0, linetype = "dashed")+
  scale_color_manual(values = c("red", "red", "black"))+
  labs(y = "fx", x = "Age")+
  theme_linedraw()

```

Lets now do the same procedure but with Hadwiger function: 

```{r}
data = fert.approx(fx = rus2010f$fx, age = 15:55, model = "Hadwiger", se = T)[[2]]
ggplot(data = data, aes(x = age))+
  geom_point(aes(y = fx, color = "Observed fx"), linewidth = 1)+
  geom_line(aes(y = fx.model, color = "fx from Hadwiger model"), linewidth = 1)+
  geom_ribbon(aes(ymin = prc.low, ymax = prc.high, x = age, color = "95% CI"), 
              alpha = 0, linetype = "dashed")+
  scale_color_manual(values = c("red", "red", "black"))+
  labs(y = "fx", x = "Age")+
  theme_linedraw()
```


Lets now do the same procedure but with Brass function: 

```{r}
data = fert.approx(fx = rus2010f$fx, age = 15:55, model = "Brass", se = T)[[2]]
ggplot(data = data, aes(x = age))+
  geom_point(aes(y = fx, color = "Observed fx"), linewidth = 1)+
  geom_line(aes(y = fx.model, color = "fx from Brass model"), linewidth = 1)+
  geom_ribbon(aes(ymin = prc.low, ymax = prc.high, x = age, color = "95% CI"), 
              alpha = 0, linetype = "dashed")+
  scale_color_manual(values = c("red", "red", "black"))+
  labs(y = "fx", x = "Age")+
  theme_linedraw()
```

Lets now do the same procedure but with Beta function: 

```{r}
data = fert.approx(fx = rus2010f$fx, age = 15:55, model = "Beta", se = T)[[2]]
ggplot(data = data, aes(x = age))+
  geom_point(aes(y = fx, color = "Observed fx"), linewidth = 1)+
  geom_line(aes(y = fx.model, color = "fx from Beta model"), linewidth = 1)+
  geom_ribbon(aes(ymin = prc.low, ymax = prc.high, x = age, color = "95% CI"), 
              alpha = 0, linetype = "dashed")+
  scale_color_manual(values = c("red", "red", "black"))+
  labs(y = "fx", x = "Age")+
  theme_linedraw()
```

# Projections

## Lee-Carter model

In the `demor` there is `leecart()` function that provides users with basic *Lee-Carter model* (proposed by @leecarter and that now has a lot of extensions, which are partially implemented in the `demor`, see documentation) for mortality forecasting:

```{r}
dbm.1 <- demor::rosbris_mortality_pop_1

leecart_forecast <- leecart(data = dbm.1[dbm.1$code==1100 & 
                                           dbm.1$territory=="t" & 
                                           dbm.1$sex=="m" & 
                                           dbm.1$year %in% 2000:2019, c("year", "age", "mx")], 
                            n = 3, 
                            sex = "m", 
                            ax_method = "classic",
                            bx_method = "classic", 
                            model = "RWwD", 
                            ktadj = "none"
                            )
```


```{r}
leecart_forecast$ex0 %>% filter(year >= 2018)
```


One can plot the results using [ggplot2](https://github.com/tidyverse/ggplot2) to compare predicted data with actual that, however, requires some data handling:

```{r}
#LE data calculation
for(i in 2020:2022){
  leecart_forecast$ex0[leecart_forecast$ex0$year ==i,]$e0.obs <- 
    LT(age = unique(dbm$age), sex = "m",
       mx = dbm[dbm$year==i & dbm$territory == "t" & dbm$code == 1100 & dbm$sex == "m",]$mx)[1,"ex"]
}

leecart_forecast$ex0 %>% 
  filter(year >= 2010) %>% 
  ggplot(aes(x = year)) + 
  geom_point(aes(y = e0.obs, color = "Observed")) +
  geom_line(aes(y = e0.obs, color = "Observed")) +
  geom_point(aes(y = e0.hat, color = "Predicted\n(counterfactual)")) + 
  geom_line(aes(y = e0.hat, color = "Predicted\n(counterfactual)")) + 
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "pink", alpha = 0.5)+
  geom_vline(xintercept = 2019, linetype = "dashed", color = "darkgrey", linewidth = 1)+
  scale_x_continuous(breaks = 2010:2024) +
  scale_y_continuous(breaks = 58:74) +
  theme_linedraw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))+
  scale_color_manual(values = c("black", "darkred"))+
  labs(x="Year", y = "Male's LE at birth", colour = "Data:")
```


The comparison between different methods of Lee-Carter model adjustment is presented below.

```{r, echo=FALSE}
data = demor::rosbris_mortality_pop_1 %>% 
  filter(territory == "t" & sex == "m" & code == 1100 & year <= 2019)

leecart_forecast <- leecart(data = data,
                            n = 3,
                            sex = "m",
                            ax_method = "classic",
                            bx_method = "classic",
                            model = "RWwD", 
                            ktadj = "none")
leecart_forecast_2000 <- leecart(data = data %>% filter(year >= 2000),
                            n = 3,
                            sex = "m",
                            ax_method = "classic",
                            bx_method = "classic",
                            model = "RWwD", 
                            ktadj = "none")

leecart_forecast_2000_last <- leecart(data = data %>% filter(year >= 2000),
                                 n = 3,
                                 sex = "m",
                                 ax_method = "last",
                                 bx_method = "classic",
                                 model = "RWwD", 
                                 ktadj = "none")
leecart_forecast_last <- leecart(data = data,
                                     n = 3,
                                     sex = "m",
                                     ax_method = "last",
                                     bx_method = "classic",
                                     model = "RWwD", 
                                     ktadj = "none")

leecart_forecast_2000_dx <- leecart(data = data %>% filter(year >= 2000),
                                      n = 3,
                                      sex = "m",
                                      ax_method = "last",
                                      bx_method = "classic",
                                      model = "RWwD", 
                                      ktadj = "e0min")
leecart_forecast_dx <- leecart(data = data,
                                 n = 3,
                                 sex = "m",
                                 ax_method = "last",
                                 bx_method = "classic",
                                 model = "RWwD", 
                                 ktadj = "e0min")


lc_plot <- leecart_forecast$ex0 %>% mutate(model = "1. Original\n1989-2019") %>%
  rbind(x = ., y = leecart_forecast_2000$ex0 %>% mutate(model = "1. Original\n2000-2019")) %>%
  rbind(x = ., y = leecart_forecast_2000_last$ex0 %>% mutate(model = "2. ax correction\n2000-2019")) %>%
  rbind(x = ., y = leecart_forecast_last$ex0 %>% mutate(model = "2. ax correction\n1989-2019")) %>% 
  rbind(x = ., y = leecart_forecast_2000_dx$ex0 %>% mutate(model = "3. kt + ax correction\n2000-2019")) %>%
  rbind(x = ., y = leecart_forecast_dx$ex0 %>% mutate(model = "3. kt + ax correction\n1989-2019"))

data = demor::rosbris_mortality_pop_1 %>% filter(territory == "t" & sex == "m" & code == 1100)
for(i in 2020:2022){
  lc_plot[lc_plot$year ==i,]$e0.obs <-
    LT(age = unique(data$age), sex = "m",
       mx = data[data$year==i,]$mx)[1,"ex"]
}

lc_plot %>%
  filter(year >= 2010) %>%
  ggplot(aes(x = year)) +
  geom_vline(xintercept = 2019, linetype = "dashed", color = "darkgrey", linewidth = 1)+
  geom_point(aes(y = e0.obs, color = "Observed")) +
  geom_line(aes(y = e0.obs, color = "Observed")) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, color = model, fill = model), alpha = 0.3, linewidth = 0.25, linetype = "dashed")+
  geom_point(aes(y = e0.hat, color = model), shape = 15) +
  geom_line(aes(y = e0.hat, color = model), linetype = "dashed") +
  scale_x_continuous(breaks = 2010:2024) +
  scale_y_continuous(breaks = 58:74) +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), legend.position = "none")+
  facet_wrap(~model, ncol = 2) +
  scale_color_manual(values = c("steelblue", "darkred", "forestgreen", "gold4", "purple", "darkorange","black" ))+
  scale_fill_manual(values = c("steelblue", "darkred", "forestgreen", "gold4", "purple", "darkorange","black" ))+
  labs(x="Year", y = "e0, males", colour = "Data:")
```


## Leslie matrix & Cohort-component model

Leslie matrix is a powerful tool for demographic analysis that was introduced by @Leslie. For a nice and detailed introduction to it and matrix projections in general, see @ess_demor, p. 98-122. Also see R package [`demogR`](https://cran.r-project.org/web/packages/demogR/index.html) and its tutorial [@demogR] for more on "matrix methods" in demography. 

In the `demor` one can compute its using $m_x$ and $f_x$ that is age-specific mortality and fertility rates respectively. 

```{r}
mx <- dbm.1[dbm.1$code==1100 & dbm.1$territory=="t" & dbm.1$sex=="f" & dbm.1$year == 2022,]$mx
fx <- dbf[dbf$code==1100 & dbf$territory=="t" & dbf$year == 2022,]$fx

les <- leslie(mx = mx, fx = fx, age.mx = 0:100, age.fx = 15:55, fin = F)

les[1:5, 1:5]
```


Leslie matrix $\pmb L$ can be expressed as $\pmb L = \pmb F + \pmb M$ where $\pmb F$ is the fertility component, which has nonzero values only across first row, and $\pmb M$ is the "survival" component, which is "shifted" down diagonal matrix. From the $\pmb M$ one can compute life expectancy vector $\pmb e$ as column sum of the matrix $\pmb E$

$$
\pmb E = (\pmb I - \pmb M)^{-1}
$$
$$
\pmb e = \pmb E^T \times \pmb 1
$$

where $\pmb I$ is an identity matrix of the same size as $\pmb M$ (so $n \times n$) and $\pmb 1$ is a column vector of size $n$ of 1. 

So, in the R it is

```{r}
M <- les
M[1,] <- 0
E <- solve(diag(nrow(M))-M)
ex = t(E) %*% rep(1, nrow(E))
head(ex)
```

The graph below compares life expectancy at age x, $e_x$, from the usual life table and from Leslie matrix (they are almost identical). However, there is a discrepancy in the last age group that is, according to the life table, has higher life expectancy than in Leslie model. This is because of the last age-group survival rate calculating. In the classical Leslie model (default in `leslie`) it is 0. It can be changed by assuming that it is $T_x/T_{x-1}$ and then the $e_x$ from life table and Leslie matrix will be identical (in `leslie` one can write `fin = TRUE` to get this; by default, it is `FALSE` as in this example). 

```{r, echo=FALSE}
plot(ex, type = "l", xlab = "age", ylab = "ex", col = "red")
lines(LT(age = 0:100, sex = "m", mx = mx)[,"ex"], col = "black")
legend("topright", legend=c("Leslie matrix", "Life table"),
       col=c("red", "black"), lty = 1, cex=0.8)
```

Also from $\pmb L$ one can compute stable population properties: stable age distribution, asymptotic growth rate, etc. For more details, references and functions see @demogR, p. 10-24 where R package [`demogR`](https://cran.r-project.org/web/packages/demogR/index.html) for matrix demographic models and their analysis was introduced. Below is some simple example how to do it "by hand":

```{r}
lambda = Re(eigen(les)$values) # largest real eigenvalue
lvector = Re(eigen(les)$vectors[,which(lambda == max(lambda))]) # corresponding eigenvector
stable_age = lvector / sum(lvector) # stable age distribution (normalized to sum to 1) 
```

The graph below compares observable and stable age distributions
```{r, echo=FALSE}
N <- dbm.1[dbm.1$code==1100 & dbm.1$territory=="t" & dbm.1$sex=="f" & dbm.1$year == 2022,]$N
## comparison of observable and stable age distributions
plot(100*N/sum(N), type = "l", xlab = "age", ylab = "% of total population")
lines(100*stable_age, col = "red")
legend("topright", legend=c("Stable", "Observable"),
       col=c("red", "black"), lty = 1, cex=0.8)
```

Finally, one of the most important implications of Leslie matrix is the demographic projection in a concise and efficient matrix form. 
$$
\pmb N(t+n) = \pmb L \times \pmb N(t)
$$
where $\pmb N(t)$ and $\pmb N(t+n)$ are column-vectors of population in the time $t$ and $t+n$ respectively. If the mortality and fertility rates are constant over time, the population in the last year of projection (of the horizon h) is simply
$$
\pmb N(t_0+n \times h) = \pmb L^h \times \pmb N(t_0)
$$

Usually to calculate the $\pmb L^h$ it is easier (and more accurate) to use iterative procedure since the modern computers are able to do it in a second (for reasonable horizon), but one surely can diagonalize $\pmb L$ and find its transition matrix to reach more efficient (though less accurate) calculations. 

Below a function for the cohort-component model `ccm()` is presented. It requires matrix or dataframe of future $m_x$ and $f_x$; and a vector with initial population. Optionally, one can provide the function with matrix or dataframe of future net number of migrants, by default it is NULL (closed population model without external migration). To produce constant rates model, one need to make matrices with identical columns, where each row is an age-specific rate and each column in a period. 


```{r}
N0 <- dbm.1[dbm.1$code==1100 & dbm.1$territory=="t" & dbm.1$sex=="f" & dbm.1$year == 2022,]$N

const.mx = matrix(rep(mx, each = 79), nrow = length(mx), byrow = TRUE)
const.fx = matrix(rep(fx, each = 79), nrow = length(fx), byrow = TRUE)

Nt <- ccm(Mx.f = const.mx, Fx = const.fx, age.mx = 0:100, age.fx = 15:55, N0.f = N0, fin = F)
colnames(Nt) <- 2022:2100

head(Nt)[,1:10]
```

And two graphs below show dynamics of total female population (in mln) and female population age structure (in %) that converges to stable population age structure. 

```{r}
plot(2022:2100, colSums(Nt)/1e6, type = "l", 
     xlab = "year", ylab = "Female Population (mln)")
```

```{r}
Nt %>% 
  as.data.frame() %>% 
  mutate(age = 0:100) %>% 
  pivot_longer(!age, names_to = "year", values_to = "pop") %>% 
  mutate(year = as.numeric(year)) %>% 
  group_by(year) %>% 
  mutate(pop.s = 100*pop / sum(pop)) %>% 
  as.data.frame() %>% 
  ggplot(aes(x = age, y = pop.s))+
  geom_line(aes(group = year, color = year))+
  scale_color_gradient(low = "pink", high = "steelblue")+
  geom_line(data = data.frame(age = 0:100, stable_age = 100*stable_age), 
            aes(x = age, y = stable_age, linetype = "Stable age\nstructure"), 
            color = "darkblue")+
  theme_classic()+
  scale_linetype_manual(values = c("longdash"))+
  labs(x = "age", y = "Age structure (%)", color = "Year:", linetype = "")
```


# Other functions

## Population pyramid

`plot_pyr` plots population pyramid using [ggplot2](https://github.com/tidyverse/ggplot2)

Lets create population pyramid using midyear population from Rosbris mortality data. We already have data in `dbm`.

```{r}

plot_pyr(
  popm = dbm[dbm$year==2022 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="m",]$N,
  popf = dbm[dbm$year==2022 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="f",]$N, 
  age = dbm[dbm$year==2022 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="f",]$age)

```

Also one can redesigned plot using [ggplot2](https://github.com/tidyverse/ggplot2) commands. Also one can plot additional population (`popm2` and `popf2`) pyramid as dashed line that can be helpful for comparisons.

```{r}

plot <- 
  plot_pyr(
  popm = dbm[dbm$year==2010 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="m",]$N,
  popf = dbm[dbm$year==2010 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="f",]$N,
  popm2 = dbm[dbm$year==2022 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="m",]$N,
  popf2 = dbm[dbm$year==2022 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="f",]$N,
  age = dbm[dbm$year==2010 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="f",]$age)

plot + 
  labs(y = "My y-axis", 
       x = "My age", 
       caption = "Data sourse: Rosbris")+
  ggtitle("Russian population in 2010")+
  scale_fill_manual(labels = c("f", "m"), values = c("pink", "lightblue"), name = "Gender:")+
  theme_minimal()

```

## Median age

Also one can compute median age of some population, using vectors of population sizes in the age groups and that age groups. 

```{r}
#Using 1-year age interval
med.age(N = dbm.1[dbm.1$year==2010 & dbm.1$code==1100 & dbm.1$territory=="t" & dbm.1$sex=="m",]$N,
        age = dbm.1[dbm.1$year==2010 & dbm.1$code==1100 & dbm.1$territory=="t" & dbm.1$sex=="m",]$age,
        int = 1)

#Using 5-year age interval
med.age(N = dbm[dbm$year==2010 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="m",]$N,
        age = dbm[dbm$year==2010 & dbm$code==1100 & dbm$territory=="t" & dbm$sex=="m",]$age,
        int = 5)
```


# References
